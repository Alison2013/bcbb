#!/usr/bin/env python
"""Explore the characteristics of a protein family by unsupervised clustering.

Using k-means clustering, groups together proteins in a family based on
several characteristics. This uses a local shelve database generated by the
interpro_domain_summary.py script.
"""
from __future__ import with_statement
import sys
import os
import shelve
import math
import collections

from mako.template import Template

import networkx
import pylab
import numpy

from Bio import Cluster

def main(ipr_number):
    #cluster_div = 20.0
    cluster_div = 20.0
    #number_clusters = 100
    db_dir = os.path.join(os.getcwd(), "db")
    cur_db = shelve.open(os.path.join(db_dir, ipr_number))
    tax_graph = build_tax_graph(cur_db)
    uniprot_ids = []
    info_array = []
    for db_domain in cur_db.keys():
        if not cur_db[db_domain].get("is_uniref_child", ""):
            uniprot_ids.append(db_domain)
            db_item = cur_db[db_domain]
            cur_cluster_info = [
                    float(db_item["charge"]),
                    float(db_item["charge_region"]) * 100.0,
                    len(db_item.get("db_refs", [])) * 5.0,
                    calc_domain_distance(db_item) * 100.0,
                    #max(len(db_item.get("string_interactors", [])) - 1, 0),
                    ]
            info_array.append(cur_cluster_info)
    info_array = numpy.array(info_array)
    #number_clusters = int(round(float(len(info_array) / cluster_div)))
    number_clusters = 10
    print 'Num genes', len(info_array), number_clusters
    cluster_ids, error, nfound = Cluster.kcluster(info_array,
            nclusters=number_clusters, npass=20)#, method='a', dist='c')
    #tree = Cluster.treecluster(info_array, method='a', dist='c')
    #cluster_ids = tree.cut(number_clusters)
    cluster_dict = collections.defaultdict(lambda: [])
    for i, cluster_id in enumerate(cluster_ids):
        cluster_dict[cluster_id].append(uniprot_ids[i])
    for index, cluster_group in enumerate(cluster_dict.values()):
        print '***********', index
        org_dists = []
        for uniprot_id in cluster_group:
            org = cur_db[uniprot_id]["org_scientific_name"]
            distance = networkx.dijkstra_path_length(tax_graph, 'Mus musculus',
                    org)
            org_dists.append((distance, org, uniprot_id))
        org_dists.sort()
        members = []
        for d, o, u in org_dists:
            members.append(dict(organism=o,
                uniprot_id=get_uniprot_links([u]),
                alt_ids=get_uniprot_links(cur_db[u].get("uniref_children", [])),
                charge=cur_db[u]["charge"],
                charge_region="%0.2f" % cur_db[u]["charge_region"],
                domains=len(cur_db[u].get("db_refs", [])),
                interactions=get_string_link(u,
                    max(len(cur_db[u].get("string_interactors", [])) - 1, 0)),
                description=cur_db[u].get("function_descr", "&nbsp;"),
                c_distance="%0.2f" % calc_domain_distance(cur_db[u]),
            ))
        with open("%s-cluster%s.html" % (ipr_number, index), "w") as out_handle:
            tmpl = Template(cluster_template)
            out_handle.write(tmpl.render(cluster_members=members))
    #distribution_plot(info_array, 2)
    #distribution_plot(cur_db, "charge")
    #distribution_plot(cur_db, "charge_region")

def calc_domain_distance(db_item):
    """Calculate the relative distance of the domain from the protein start.

    Our expectation is that our domains will be located in the N-terminal
    region of the protein, and this calculates the relative distance from the
    N-terminal.
    """
    domain_start = min(db_item["domain_positions"])
    return float(domain_start) / float(len(db_item["seq"]))

def get_string_link(uniprot_id, num_interactors):
    if num_interactors == 0:
        return num_interactors
    else:
        return '<a href="http://string.embl.de/newstring_cgi/' + \
            'show_network_section.pl?identifier=' + uniprot_id + \
            '">' + str(num_interactors)+'</a>'

def get_uniprot_links(uniprot_ids):
    """Generate links to uniprot for a set of IDs. Simple HTML generation.
    """
    links = ['<a href="http://www.uniprot.org/uniprot/%s">%s</a>' % ((u,) * 2)
            for u in uniprot_ids]
    if len(links) == 0:
        return '&nbsp;'
    else:
        return '<br/>'.join(links)

cluster_template = """
<html>
<body>
<table border="1">
<tr>
  <th><b>Organism</b></th>
  <th><b>Protein</b></th>
  <th><b>Other names</b></th>
  <th><b>Charge</b></th>
  <th><b>Regional charge</b></th>
  <th><b>Domains</b></th>
  <th><b>Interactions</b></th>
  <th><b>N-terminal distance</b></th>
  <th><b>Description</b></th>
</tr>
% for member in cluster_members:
    <tr>
        <td>${member['organism']}</td>
        <td>${member['uniprot_id']}</td>
        <td>${member['alt_ids']}</td>
        <td>${member['charge']}</td>
        <td>${member['charge_region']}</td>
        <td>${member['domains']}</td>
        <td>${member['interactions']}</td>
        <td>${member['c_distance']}</td>
        <td>${member['description']}</td>
    </tr>
% endfor
</table>
</body>
</html>
"""

def distribution_plot(item_array, index_num):
    vals = [x[index_num] for x in item_array]
    #vals = []
    #for db_domain in cur_db.keys():
    #    vals.append(cur_db[db_domain][item_key])
    pylab.hist(vals, 20)
    pylab.show()

def build_tax_graph(cur_db):
    """Build a taxonomy graph of all organisms represented with a given domain.

    This is a relative graph in that all distances are 1 back to the top level,
    but will allow estimation of evolutionary distances based on the 
    NCBI/UniProt organism lineage trees.
    """
    tax_graph = networkx.Graph()
    organisms_done = []
    use_dict = collections.defaultdict(int)
    for db_domain in cur_db.keys():
        db_item = cur_db[db_domain]
        if db_item["org_scientific_name"] not in organisms_done:
            full_lineage = db_item["org_lineage"] + \
                    [db_item["org_scientific_name"]]
            distance = 1.0
            for index in range(len(full_lineage) - 1):
                use_dict[full_lineage[index]] += 1
                tax_graph.add_edge(full_lineage[index], full_lineage[index + 1],
                        distance)
            organisms_done.append(db_item["org_scientific_name"])
    return tax_graph

if __name__ == "__main__":
    if len(sys.argv) != 2:
        print "Incorrect arguments"
        print __doc__
        sys.exit()
    main(sys.argv[1])
